SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;
CREATE SCHEMA hr;
ALTER SCHEMA hr OWNER TO postgres;
SET default_tablespace = '';
SET default_table_access_method = heap;
CREATE TABLE hr.country (
    country_id character(2) NOT NULL,
    country_name character varying(40),
    id_region integer
);
ALTER TABLE hr.country OWNER TO postgres;
COMMENT ON TABLE hr.country IS 'country table. Contains 3 rows. References with region table.';
COMMENT ON COLUMN hr.country.country_id IS 'Primary key of country table.';
COMMENT ON COLUMN hr.country.country_name IS 'Country name';
COMMENT ON COLUMN hr.country.id_region IS 'Region ID for the country. Foreign key to region_id column in the region table.';
CREATE TABLE hr.department (
    department_id integer NOT NULL,
    department_name character varying(30) NOT NULL,
    id_manager integer,
    id_location integer
);
ALTER TABLE hr.department OWNER TO postgres;
COMMENT ON TABLE hr.department IS 'department table that shows details of departments where employees work. Contains 27 rows; references with location, employee, and job_history tables.';
COMMENT ON COLUMN hr.department.department_id IS 'Primary key column of department table.';
COMMENT ON COLUMN hr.department.department_name IS 'A not null column that shows name of a department. Administration, Marketing, Purchasing, Human Resources, Shipping, IT, Executive, Public Relations, Sales, Finance, and Accounting. ';
COMMENT ON COLUMN hr.department.id_manager IS 'Manager_id of a department. Foreign key to employee_id column of employee table. The manager_id column of the employee table references this column.';
COMMENT ON COLUMN hr.department.id_location IS 'Location id where a department is located. Foreign key to location_id column of location table.';
ALTER TABLE hr.department
ALTER COLUMN department_id
ADD GENERATED BY DEFAULT AS IDENTITY (
        SEQUENCE NAME hr.department_department_id_seq START WITH 280 INCREMENT BY 10 NO MINVALUE NO MAXVALUE CACHE 1
    );
CREATE TABLE hr.employee (
    employee_id integer NOT NULL,
    first_name character varying(20) NOT NULL,
    last_name character varying(25) NOT NULL,
    email character varying(25) NOT NULL,
    phone_number character varying(20),
    hire_date date NOT NULL,
    id_job character varying(10) NOT NULL,
    salary numeric(8, 2),
    commission_pct numeric(2, 2),
    id_manager integer,
    id_department integer,
    CONSTRAINT employee_salary_min CHECK ((salary > (0)::numeric))
);
ALTER TABLE hr.employee OWNER TO postgres;
COMMENT ON TABLE hr.employee IS 'employee table. Contains 107 rows. References with department, job, job_history tables. Contains a self reference.';
COMMENT ON COLUMN hr.employee.employee_id IS 'Primary key of employee table.';
COMMENT ON COLUMN hr.employee.first_name IS 'First name of the employee. A not null column.';
COMMENT ON COLUMN hr.employee.last_name IS 'Last name of the employee. A not null column.';
COMMENT ON COLUMN hr.employee.email IS 'Email id of the employee. A not null column.';
COMMENT ON COLUMN hr.employee.phone_number IS 'Phone number of the employee; includes country code and area code';
COMMENT ON COLUMN hr.employee.hire_date IS 'Date when the employee started on this job. A not null column.';
COMMENT ON COLUMN hr.employee.id_job IS 'Current job of the employee; foreign key to job_id column of the job table. A not null column.';
COMMENT ON COLUMN hr.employee.salary IS 'Monthly salary of the employee. Must be greater than zero (enforced by constraint emp_salary_min)';
COMMENT ON COLUMN hr.employee.commission_pct IS 'Commission percentage of the employee; Only employees in sales department elgible for commission percentage';
COMMENT ON COLUMN hr.employee.id_manager IS 'Manager id of the employee; has same domain as manager_id in department table. Foreign key to employee_id column of employee table.(useful for reflexive joins and CONNECT BY query)';
COMMENT ON COLUMN hr.employee.id_department IS 'Department id where employee works; foreign key to department_id column of the department table';
CREATE TABLE hr.job (
    job_id character varying(10) NOT NULL,
    job_title character varying(35) NOT NULL,
    min_salary integer,
    max_salary integer
);
ALTER TABLE hr.job OWNER TO postgres;
COMMENT ON TABLE hr.job IS 'job table with job titles and salary ranges. Contains 19 rows. References with employee and job_history table.';
COMMENT ON COLUMN hr.job.job_id IS 'Primary key of job table.';
COMMENT ON COLUMN hr.job.job_title IS 'A not null column that shows job title, e.g. AD_VP, FI_ACCOUNTANT';
COMMENT ON COLUMN hr.job.min_salary IS 'Minimum salary for a job title.';
COMMENT ON COLUMN hr.job.max_salary IS 'Maximum salary for a job title';
CREATE TABLE hr.location (
    location_id integer NOT NULL,
    street_address character varying(40),
    postal_code character varying(12),
    city character varying(30) NOT NULL,
    state_province character varying(25),
    id_country character(2)
);
ALTER TABLE hr.location OWNER TO postgres;
COMMENT ON TABLE hr.location IS 'location table that contains specific address of a specific office, warehouse, and/or production site of a company. Does not store addresses locations of customers. Contains 6 rows; references with the department and country tables. ';
COMMENT ON COLUMN hr.location.location_id IS 'Primary key of location table';
COMMENT ON COLUMN hr.location.street_address IS 'Street address of an office, warehouse, or production site of a company.  Contains building number and street name';
COMMENT ON COLUMN hr.location.postal_code IS 'Postal code of the location of an office, warehouse, or production site of a company. ';
COMMENT ON COLUMN hr.location.city IS 'A not null column that shows city where an office, warehouse, or production site of a company is located. ';
COMMENT ON COLUMN hr.location.state_province IS 'State or Province where an office, warehouse, or production site of a company is located.';
COMMENT ON COLUMN hr.location.id_country IS 'Country where an office, warehouse, or production site of a company is located. Foreign key to country_id column of the country table.';
CREATE TABLE hr.region (
    region_id integer NOT NULL,
    region_name character varying(25)
);
ALTER TABLE hr.region OWNER TO postgres;
COMMENT ON TABLE hr.region IS 'Region table that contains region numbers and names. Contains 2 rows; references with the country table.';
COMMENT ON COLUMN hr.region.region_id IS 'Primary key of region table.';
COMMENT ON COLUMN hr.region.region_name IS 'Names of regions. Locations are in the countries of these regions.';
CREATE VIEW hr.emp_details_view AS
SELECT e.employee_id,
    e.id_job AS job_id,
    e.id_manager AS manager_id,
    e.id_department AS department_id,
    d.id_location AS location_id,
    l.id_country AS country_id,
    e.first_name,
    e.last_name,
    e.salary,
    e.commission_pct,
    d.department_name,
    j.job_title,
    l.city,
    l.state_province,
    c.country_name,
    r.region_name
FROM hr.employee e,
    hr.department d,
    hr.job j,
    hr.location l,
    hr.country c,
    hr.region r
WHERE (
        (e.id_department = d.department_id)
        AND (d.id_location = l.location_id)
        AND (l.id_country = c.country_id)
        AND (c.id_region = r.region_id)
        AND ((e.id_job)::text = (j.job_id)::text)
    );
ALTER VIEW hr.emp_details_view OWNER TO postgres;
ALTER TABLE hr.employee
ALTER COLUMN employee_id
ADD GENERATED BY DEFAULT AS IDENTITY (
        SEQUENCE NAME hr.employee_employee_id_seq START WITH 207 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
    );
CREATE TABLE hr.job_grade (
    grade_level character varying(3),
    lowest_sal integer,
    highest_sal integer
);
ALTER TABLE hr.job_grade OWNER TO postgres;
CREATE TABLE hr.job_history (
    id_employee integer NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    id_job character varying(10) NOT NULL,
    id_department integer,
    CONSTRAINT jobhistory_date_interval CHECK ((end_date > start_date))
);
ALTER TABLE hr.job_history OWNER TO postgres;
COMMENT ON TABLE hr.job_history IS 'Table that stores job history of the employees. If an employee changes departments within the job or changes jobs within the department, new rows get inserted into this table with old job information of the employee. Contains a complex primary key: employee_id+start_date. Contains 25 rows. References with job, employee, and department tables.';
COMMENT ON COLUMN hr.job_history.id_employee IS 'A not null column in the complex primary key employee_id+start_date. Foreign key to employee_id column of the employee table';
COMMENT ON COLUMN hr.job_history.start_date IS 'A not null column in the complex primary key employee_id+start_date. Must be less than the end_date of the job_history table. (enforced by constraint jhist_date_interval)';
COMMENT ON COLUMN hr.job_history.end_date IS 'Last day of the employee in this job role. A not null column. Must be greater than the start_date of the job_history table. (enforced by constraint jhist_date_interval)';
COMMENT ON COLUMN hr.job_history.id_job IS 'Job role in which the employee worked in the past; foreign key to job_id column in the job table. A not null column.';
COMMENT ON COLUMN hr.job_history.id_department IS 'Department id in which the employee worked in the past; foreign key to deparment_id column in the department table';
ALTER TABLE hr.job_history
ALTER COLUMN id_employee
ADD GENERATED BY DEFAULT AS IDENTITY (
        SEQUENCE NAME hr.job_history_id_employee_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
    );
ALTER TABLE hr.location
ALTER COLUMN location_id
ADD GENERATED BY DEFAULT AS IDENTITY (
        SEQUENCE NAME hr.location_location_id_seq START WITH 3300 INCREMENT BY 100 NO MINVALUE NO MAXVALUE CACHE 1
    );
ALTER TABLE hr.region
ALTER COLUMN region_id
ADD GENERATED BY DEFAULT AS IDENTITY (
        SEQUENCE NAME hr.region_region_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
    );
CREATE TABLE hr.version (
    version_id integer NOT NULL,
    date timestamp without time zone NOT NULL,
    version_number integer NOT NULL
);
ALTER TABLE hr.version OWNER TO postgres;
COMMENT ON TABLE hr.version IS 'Version table that contains the version information of the database content and structure';
ALTER TABLE hr.version
ALTER COLUMN version_id
ADD GENERATED BY DEFAULT AS IDENTITY (
        SEQUENCE NAME hr.version_version_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
    );
ALTER TABLE ONLY hr.country
ADD CONSTRAINT country_pkey PRIMARY KEY (country_id);
ALTER TABLE ONLY hr.department
ADD CONSTRAINT department_pkey PRIMARY KEY (department_id);
ALTER TABLE ONLY hr.employee
ADD CONSTRAINT employee_email_ukey UNIQUE (email);
ALTER TABLE ONLY hr.employee
ADD CONSTRAINT employee_pkey PRIMARY KEY (employee_id);
ALTER TABLE ONLY hr.job_history
ADD CONSTRAINT job_history_pkey PRIMARY KEY (id_employee, start_date);
ALTER TABLE ONLY hr.job
ADD CONSTRAINT job_pkey PRIMARY KEY (job_id);
ALTER TABLE ONLY hr.location
ADD CONSTRAINT location_pkey PRIMARY KEY (location_id);
ALTER TABLE ONLY hr.region
ADD CONSTRAINT region_pkey PRIMARY KEY (region_id);
ALTER TABLE ONLY hr.version
ADD CONSTRAINT version_pkey PRIMARY KEY (version_id);
ALTER TABLE ONLY hr.country
ADD CONSTRAINT country_id_region_fkey FOREIGN KEY (id_region) REFERENCES hr.region(region_id);
ALTER TABLE ONLY hr.department
ADD CONSTRAINT department_id_location_fkey FOREIGN KEY (id_location) REFERENCES hr.location(location_id);
ALTER TABLE ONLY hr.department
ADD CONSTRAINT department_id_manager_fkey FOREIGN KEY (id_manager) REFERENCES hr.employee(employee_id) ON DELETE CASCADE;
ALTER TABLE ONLY hr.employee
ADD CONSTRAINT employee_id_department_fkey FOREIGN KEY (id_department) REFERENCES hr.department(department_id);
ALTER TABLE ONLY hr.employee
ADD CONSTRAINT employee_id_job_fkey FOREIGN KEY (id_job) REFERENCES hr.job(job_id);
ALTER TABLE ONLY hr.employee
ADD CONSTRAINT employee_id_manager_fkey FOREIGN KEY (id_manager) REFERENCES hr.employee(employee_id);
ALTER TABLE ONLY hr.job_history
ADD CONSTRAINT job_history_id_department_fkey FOREIGN KEY (id_department) REFERENCES hr.department(department_id);
ALTER TABLE ONLY hr.job_history
ADD CONSTRAINT job_history_id_employee_fkey FOREIGN KEY (id_employee) REFERENCES hr.employee(employee_id);
ALTER TABLE ONLY hr.job_history
ADD CONSTRAINT job_history_id_job_fkey FOREIGN KEY (id_job) REFERENCES hr.job(job_id);
ALTER TABLE ONLY hr.location
ADD CONSTRAINT location_id_country_fkey FOREIGN KEY (id_country) REFERENCES hr.country(country_id);
GRANT ALL ON SCHEMA hr TO cyrill;
GRANT SELECT ON TABLE hr.country TO cyrill;
GRANT SELECT ON TABLE hr.department TO cyrill;
GRANT SELECT ON TABLE hr.employee TO cyrill;
GRANT SELECT ON TABLE hr.job TO cyrill;
GRANT SELECT ON TABLE hr.location TO cyrill;
GRANT SELECT ON TABLE hr.region TO cyrill;
GRANT SELECT ON TABLE hr.emp_details_view TO cyrill;
GRANT SELECT ON TABLE hr.job_grade TO cyrill;
GRANT SELECT ON TABLE hr.job_history TO cyrill;
GRANT SELECT ON TABLE hr.version TO cyrill;